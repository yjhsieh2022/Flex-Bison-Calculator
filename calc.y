%{
#include <iostream>
#include "math.h"
#include "util.h"
#include <string>
#include <unordered_map>

std::unordered_map<std::string, double> mapping;        /* create map name mapping to store variable */

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "error: " << p << std::endl; };
%}



%union {
    double num;
    std::string* var; 
};

%start program_input

%token ADD SUB MUL DIV POW MOD SQRT FACTORIAL EQUALS
%token PI ABS FLOOR CEIL COS SIN TAN LOG2 LOG10 
%token L_BRACKET R_BRACKET
%token GBP_TO_USD USD_TO_GBP GBP_TO_EURO EURO_TO_GBP USD_TO_EURO EURO_TO_USD 
%token CEL_TO_FAH FAH_TO_CEL 
%token MI_TO_KM KM_TO_MI 
%token VAR_KEYWORD
%token EOL
%token <num> NUMBER
%token <var> VARIABLE

%type <num> program_input line calculation constant expr function trig_function log_function 
%type <num> conversion temp_conversion dist_conversion assignment


%left SUB ADD
%left MUL DIV SIN COS TAN
%left POW SQRT  
%left L_BRACKET R_BRACKET


%%

program_input : program_input line          
              |                             /* ctl+c will exit the code */
              ;

line : EOL                              { printf("Empty line\n"); }
     | calculation EOL                  { printf("=%.2f\n",$1); }
     ; 
            
calculation : expr
            | assignment
            ;

constant : PI                           { $$ = 3.14; }
         ; 

expr : SUB expr                         { $$ = -$2; }
     | NUMBER                           { $$ = $1; }
     | VARIABLE                         { std::string str = *($1); if(mapping.find(str) == mapping.end()) {std::string err = "No variable found."; yyerror(err.c_str());} $$ = mapping[str]; }
     | constant
     | function
     | expr DIV expr                    { $$ = $1 / $3; }
     | expr MUL expr                    { $$ = $1 * $3; }
     | expr ADD expr                    { $$ = $1 + $3; }
     | expr SUB expr                    { $$ = $1 - $3; }
     | expr POW expr                    { $$ = pow($1, $3); }
     | expr MOD expr                    { $$ = modulo($1, $3); }
     | L_BRACKET expr R_BRACKET         { $$ = $2; }
     ;

function : conversion                    
         | log_function                 
         | trig_function                    
         | expr FACTORIAL               { $$ = factorial($1); }     
         | SQRT expr                    { $$ = sqrt($2); }
         | ABS expr                     { $$ = abs($2); }
         | FLOOR expr                   { $$ = floor($2); }
         | CEIL expr                    { $$ = ceil($2); }
         ;

trig_function : COS expr                { $$ = cos($2); }
              | SIN expr                { $$ = sin($2); }
              | TAN expr                { $$ = tan($2); }
              ; 

log_function : LOG2 expr                { $$ = log2($2); }
             | LOG10 expr               { $$ = log10($2); }
             ; 

conversion : temp_conversion            
           | dist_conversion            
           | expr GBP_TO_USD            { $$ = gbp_to_usd($1); }
           | expr USD_TO_GBP            { $$ = usd_to_gbp($1); }
           | expr GBP_TO_EURO           { $$ = gbp_to_euro($1);}
           | expr EURO_TO_GBP           { $$ = euro_to_gbp($1); }
           | expr USD_TO_EURO           { $$ = usd_to_euro($1); }
           | expr EURO_TO_USD           { $$ = euro_to_usd($1); }
           ; 

temp_conversion : expr CEL_TO_FAH       { $$ = cel_to_fah($1); }
                | expr FAH_TO_CEL       { $$ = fah_to_cel($1); }
                ; 

dist_conversion : expr MI_TO_KM         { $$ = m_to_km($1); }
                | expr KM_TO_MI         { $$ = km_to_m($1); }
                ; 

assignment :  VAR_KEYWORD VARIABLE EQUALS calculation       { std::string str = *($2); mapping[str] = $4; $$ = $4; }
           ;


%%
int main()
{
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
}